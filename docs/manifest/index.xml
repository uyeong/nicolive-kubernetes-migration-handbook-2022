<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>매니페스트 관리 on 니코니코 생방송 웹 프런트엔드의 쿠버네티스 이전 핸드북 2022</title><link>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/</link><description>Recent content in 매니페스트 관리 on 니코니코 생방송 웹 프런트엔드의 쿠버네티스 이전 핸드북 2022</description><generator>Hugo -- gohugo.io</generator><language>kr-KR</language><atom:link href="https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/index.xml" rel="self" type="application/rss+xml"/><item><title>쿠버네티스의 매니페스트 관리</title><link>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/manifest-management/</guid><description>쿠버네티스의 매니페스트 관리 # 이번 장에서는 매니페스트 관리를 어떻게 하고 있는지 소개한다. 결론부터 말하면 우리는 쿠버네티스에서 이용할 매니페스트를 생성해 주는 제너레이터를 타입스크립트로 구축했다.
어떻게 구축하여 운용하고 있는지 설명한다.
이전 후 각 컴포넌트의 파일 수로 살펴보는 규모 # 도입 부분에서 다뤘던 자료를 다시금 언급. 프런트엔드와 관련한 마이크로서비스의 매니페스트는 다음과 같은 규모로 존재한다. 이는 간단히 관리할 수 없는 컴포넌트 수이며 앞으로도 늘어날 전망이다.
컴포넌트 파일 수 v1/Deployment 20 v1/Service 60 v1/Config Map 15 batch/v1/Job 15 argoproj.</description></item><item><title>TypeScriptでKubernetesのmanifestを記述する</title><link>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-written-by-typescript/</guid><description>TypeScriptでKubernetesのmanifestを記述する # ここでは基本的な書き方について紹介します。
基本的な書き方 # NodeJSで動かすスクリプトとして次のようなに記述してきます。 これをts-nodeなどで実行するとdeployment.ymlが出力され、kubectl apply -f deployment.ymlとすることでKubernetes上にPodが起動します。
import * as fs from &amp;#34;fs&amp;#34;; import * as yaml from &amp;#34;js-yaml&amp;#34;; import type { Schemas } from &amp;#34;@himenon/kubernetes-typescript-openapi/v1.22.3&amp;#34;; const podTemplateSpec: Schemas.io$k8s$api$core$v1$PodTemplateSpec = { metadata: { labels: { app: &amp;#34;nginx&amp;#34;, }, }, spec: { containers: [ { name: &amp;#34;nginx&amp;#34;, image: &amp;#34;nginx:1.14.2&amp;#34;, ports: [ { containerPort: 80, }, ], }, ], }, }; const deployment: Schemas.</description></item><item><title>TypeScriptでManifestを生成するGeneratorのアーキテクチャ</title><link>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uyeong.github.io/nicolive-kubernetes-migration-handbook-2022/docs/manifest/kubernetes-manifest-generator-architecture/</guid><description>TypeScriptでManifestを生成するGeneratorのアーキテクチャ # アーキテクチャが解決すること # そもそも Generator そのものが解決することは manifest をドキュメントの乖離を防ぎ、YAMLの記法のぶれなどを防ぐことです。 アーキテクチャが解決しなければいけないことは、具体的には次のようなことが挙げられます。
マニフェスト自体のスケーラビリティを確保する 実際に運用する際に必要最小限の変更だけで Manifest を更新できる ≒ 宣言的な変更で済むようにする マイクロサービス単位で設定の変更ができる（CPU/MEM/replicas など） 管理しているマイクロサービス全体のリソース量、変更時の増減が把握できる Manifest ファイルの命名規則、出力先のディレクトリ・ファイルツリーなどを意識しなくても良い Generator 自体の保守性を高める これらを表現するためのアーキテクチャはStatic Site GeneratorやYeoman、Cookiecutter、Rails Scaffoldなどたくさん事例があります。 これらの基本的な骨格をKubernetesのManifest Generatorとして応用し次のようなアーキテクチャが設計しました。
それぞれの役割を紹介します。
名称 役割 User Config バージョン変更など最小限の変更を与えるファイル Kubernetes TypeDefinition TypeScriptの型定義 MicroService Template マイクロサービスの種類に応じたテンプレート Definition Namespace名やPort番号、Gatewayの Host 名などの不動値の定義 Resource ParameterとMicroService Templateを Kubernetes のリソースコンポーネント単位で結合する Factory Resourceをどのファイル名でどのグループで出力するか定義する Writer Factory から与えられた情報から Kubernetes の Manifest や、CPU Requests などのレポートを生成する 具体的な実装例 # 実装サンプルを以下のリポジトリに用意しました。nodejsとpnpmを利用したサンプルとなっています。 Docker Swarmを利用すればArgo Rollouts + Istioがデプロイできるところまで確認しています。</description></item></channel></rss>